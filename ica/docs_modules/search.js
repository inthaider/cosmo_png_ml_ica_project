window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "modules", "modulename": "modules", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "modules.fields_gauss", "modulename": "modules.fields_gauss", "kind": "module", "doc": "<p>This module contains functions for generating initial conditions for the 1D \\zeta and \\chi_e^2 Gaussian Random Fields (GRFs).</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>pk_primordial_1d\n    Returns the primordial power spectrum for a pure 1D \\zeta GRF.\ngrf_zeta_1d\n    Generate a 1D \\zeta GRF with power spectrum given by the primordial power spectrum.</p>\n\n<p>pk_primordial_3d\n    Returns the primordial power spectrum for a pure 3D \\zeta GRF.\ngrf_zeta_3d_los1d\n    Generate a 1D \\zeta GRF from the power spectrum for a 3D\n    \\zeta GRF (acts as a line-of-sight 1D strip).</p>\n\n<p>pk_chi_1d\n    Returns the power spectrum for a 1D \\chi_e^2 GRF.\ngrf_chi_1d\n    Generate a 1D \\chi_e^2 GRF from the power spectrum for a 1D \\chi_e^2 GRF.</p>\n\n<p>pk_chi_3d\n    Returns the power spectrum for a 3D \\chi_e^2 GRF.\ngrf_chi_3d_los1d\n    Generate a 1D, 'Line-Of-Sight' \\chi_e^2 GRF from the power spectrum \n    generated for a 3D \\chi_e^2 GRF.</p>\n\n<p>gauss_var\n    Generates a complex Gaussian random variable in Fourier space with zero mean and unit variance.\ndealiasx\n    Dealias a real space field and return the de-aliased field in real space domain.\ndealiask\n    Dealias a Fourier space field and return the de-aliased field in Fourier space domain.</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Change the numpy random seed generation to the new, recommended method.</p>\n"}, {"fullname": "modules.fields_gauss.pk_primordial_1d", "modulename": "modules.fields_gauss", "qualname": "pk_primordial_1d", "kind": "function", "doc": "<p>Returns the primordial power spectrum for a pure 1D \\zeta GRF.</p>\n\n<p>This is a function that returns the primordial power spectrum in 1D.\nIt is a one-parameter model of the primordial power spectrum.\nIt is a power law with a scale-invariant power spectrum.\nThe power law is of the form P(k) = (pi/k) * A * k^(n_s-1), where \nk is the wavenumber, A is the amplitude, and n_s is the spectral index.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>k\n    Array of wavenumbers.\namplitude : float, optional\n    Amplitude of the primordial power spectrum.\nn_s : float, optional\n    Spectral index of the primordial power spectrum.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>power_spectrum\n    The primordial power spectrum.</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Need to put into the GRF (g): tilt and amplitude</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">amplitude</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">n_s</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.grf_zeta_1d", "modulename": "modules.fields_gauss", "qualname": "grf_zeta_1d", "kind": "function", "doc": "<p>Generate a 1D \\zeta GRF with power spectrum given by\nthe primordial power spectrum.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N : int\n    Size of the input array.\npk_amp : float, optional\n    Amplitude of the primordial power spectrum.\npk_ns : float, optional\n    Spectral index of the primordial power spectrum.\nkmaxknyq_ratio : float, optional\n    Ratio of kmax to the Nyquist frequency. The Nyquist frequency is\n    given by np.pi * N. The default value of 2/3 is consistent with\n    the usual practice of simulating a 2D field with a 1D FFT.\nseed : optional\n    Seed for the random number generator. If set to None, the seed is\n    set to 0. If set to an integer, it is used as the seed directly.\n    If set to a tuple, it is assumed to be a random state generated by\n    np.random.get_state().</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>zeta\n    The mean-subtracted, variance-normalized \\zeta GRF.</p>\n\n<h2 id=\"notes\">Notes</h2>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">N</span>,</span><span class=\"param\">\t<span class=\"n\">pk_amp</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">pk_ns</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.pk_primordial_3d", "modulename": "modules.fields_gauss", "qualname": "pk_primordial_3d", "kind": "function", "doc": "<p>Returns the primordial power spectrum for a 3D \\zeta GRF.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>k\n    Array of wavenumbers.\namp : float, optional\n    Amplitude of the primordial power spectrum.\nns : float, optional\n    Spectral index of the primordial power spectrum.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pk\n    The primordial power spectrum in 3D.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The power spectrum is given by P(k) = (2*pi^2) * A * k^(n_s-1) / k^3.</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Need to put into the GRF (g): tilt and amplitude</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">amp</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">ns</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.grf_zeta_3d_los1d", "modulename": "modules.fields_gauss", "qualname": "grf_zeta_3d_los1d", "kind": "function", "doc": "<p>Generate a 1D \\zeta GRF from the power spectrum for a 3D\n\\zeta GRF (acts as a line-of-sight 1D strip).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N : int\n    Size of the real space field.\npk_amp : float, optional\n    Amplitude of the primordial power spectrum.\npk_ns : float, optional\n    Spectral index of the primordial power spectrum.\nseed : optional\n    Seed for the random number generator. If set to None, the seed is\n    set to 0. If set to an integer, it is used as the seed directly.\n    If set to a tuple, it is assumed to be a random state generated by\n    np.random.get_state().</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>zeta\n    The variance-normalized \\zeta GRF.        </p>\n\n<h2 id=\"notes\">Notes</h2>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">pk_amp</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">pk_ns</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.pk_chi_1d", "modulename": "modules.fields_gauss", "qualname": "pk_chi_1d", "kind": "function", "doc": "<p>Returns the power spectrum for a 1D \\chi_e^2 GRF.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>k\n    Array of wavenumbers.\namp\n    Amplitude of the primordial power spectrum.\nR\n    Parameter for the power spectrum.\nB : float, optional\n    Parameter for the power spectrum.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pk\n    The power spectrum in 1D.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The power spectrum is given by P(k) = (pi / k) * A * R^2 * k^2 * (exp(-R^2 * k^2) + B).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">amp</span>, </span><span class=\"param\"><span class=\"n\">R</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.grf_chi_1d", "modulename": "modules.fields_gauss", "qualname": "grf_chi_1d", "kind": "function", "doc": "<p>Generate a 1D \\chi_e^2 GRF from the power spectrum.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N : int\n    Size of the real space field.\npk_amp\n    Amplitude of the primordial power spectrum.\npk_R\n    Parameter for the power spectrum.\npk_B : float, optional\n    Parameter for the power spectrum.\nkmaxknyq_ratio : float, optional\n    Ratio of the maximum wavenumber to the Nyquist wavenumber.\nseed : optional\n    Seed for the random number generator. If set to None, the seed is\n    set to 0. If set to an integer, it is used as the seed directly.\n    If set to a tuple, it is assumed to be a random state generated by\n    np.random.get_state().</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>chi\n    The mean-subtracted, variance-normalized \\chi_e^2 GRF.</p>\n\n<h2 id=\"notes\">Notes</h2>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">N</span>,</span><span class=\"param\">\t<span class=\"n\">pk_amp</span>,</span><span class=\"param\">\t<span class=\"n\">pk_R</span>,</span><span class=\"param\">\t<span class=\"n\">pk_B</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span>,</span><span class=\"param\">\t<span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.pk_chi_3d", "modulename": "modules.fields_gauss", "qualname": "pk_chi_3d", "kind": "function", "doc": "<p>Returns the power spectrum for a 3D \\chi_e^2 GRF.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>k\n    Array of wavenumbers.\namp\n    Amplitude of the primordial power spectrum.\nR\n    Parameter for the power spectrum.\nB : float, optional\n    Parameter for the power spectrum.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>pk\n    The 3D power spectrum.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The power spectrum is given by P(k) = (2*pi^2 / k^3) * A * R^2 * k^2 * exp(-R^2 * k^2 + B).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">amp</span>, </span><span class=\"param\"><span class=\"n\">R</span>, </span><span class=\"param\"><span class=\"n\">B</span><span class=\"o\">=</span><span class=\"mf\">0.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.grf_chi_3d_los1d", "modulename": "modules.fields_gauss", "qualname": "grf_chi_3d_los1d", "kind": "function", "doc": "<p>Generate a 1D, 'Line-Of-Sight' \\chi_e^2 GRF from the power spectrum \ngenerated for a 3D \\chi_e^2 GRF.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N : int\n    Size of the real space field.\npk_amp\n    Amplitude of the primordial power spectrum.\npk_R\n    Parameter for the power spectrum.\npk_B : float, optional\n    Parameter for the power spectrum.\nseed : optional\n    Seed for the random number generator. If set to None, the seed is\n    set to 0. If set to an integer, it is used as the seed directly.\n    If set to a tuple, it is assumed to be a random state generated by\n    np.random.get_state().</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>chi\n    The variance-normalized \\chi_e^2 GRF.</p>\n\n<h2 id=\"notes\">Notes</h2>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">pk_amp</span>, </span><span class=\"param\"><span class=\"n\">pk_R</span>, </span><span class=\"param\"><span class=\"n\">pk_B</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.gauss_var", "modulename": "modules.fields_gauss", "qualname": "gauss_var", "kind": "function", "doc": "<p>Generates a complex Gaussian random variable in Fourier space with zero mean and unit variance.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>size : int\n    The size of the Gaussian random deviate array to be generated.\nseed : optional\n    Seed for the random number generator. If set to None, the seed is\n    set to 0. If set to an integer, it is used as the seed directly.\n    If set to a tuple, it is assumed to be a random state generated by\n    np.random.get_state().</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>a * (np.cos(e) + 1j * np.sin(e))\n    The complex Gaussian random deviate array.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The random number generator is set to the seed if it is not None.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.dealiasx", "modulename": "modules.fields_gauss", "qualname": "dealiasx", "kind": "function", "doc": "<p>Dealias a real space field and return the de-aliased field in real space domain.</p>\n\n<p>Set the Fourier coefficients to zero if the wavenumber is greater than the maximum wavenumber (kmax), defined to be 2/3 of the Nyquist frequency.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>f\n    Input field in real space.\nkmaxknyq_ratio : float, optional\n    The ratio of the maximum wavenumber to the Nyquist wavenumber.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ff\n    The de-aliased field in real space.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The 2/3 ratio is commonly used in the literature.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_gauss.dealiask", "modulename": "modules.fields_gauss", "qualname": "dealiask", "kind": "function", "doc": "<p>Dealias a Fourier space field and return the de-aliased field in Fourier space domain.</p>\n\n<p>Set the Fourier coefficients to zero if the wavenumber is greater than the maximum wavenumber (kmax), defined to be 2/3 of the Nyquist frequency.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N\n    The size of the real field array.\nfk\n    Input field in Fourier space.\nk\n    Array of wavenumbers.\nkmaxknyq_ratio : float, optional\n    The ratio of the maximum wavenumber to the Nyquist wavenumber.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fk\n    The de-aliased field in Fourier space.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The 2/3 ratio is commonly used in the literature.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">fk</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong", "modulename": "modules.fields_nong", "kind": "module", "doc": "<p>This module contains functions for generating various forms of Non-Gaussian Primodial components and fields.</p>\n\n<p>The non-Gaussian components are added to the Gaussian Random Fields (GRFs) to create the final, non-Gaussian Primordial Fields.</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>png_chisq\n    Generate Chi_e^2 Non-Gaussianity (only the FNG component, not the whole field) and return its correlated GRF too.\npng_asymsinh\n    Generate Asymmetric Sinh Non-Gaussianity (only the FNG component, not the full NG field).\npng_map_asymsinh\n    Map a GRF to an Asymmetric $\\sinh$ Non-Gaussian component.\nkth_root\n    Return the kth root of x.</p>\n\n<p>png_field_chisq\n    Generate the full Chi_e^2 Non-Gaussian Field.\npng_field_asymsinh_corr\n    Generate the full Asymmetric Sinh Non-Gaussian Field with correlated components.\npng_field_asymsinh_uncorr\n    Generate the full Asymmetric Sinh Non-Gaussian Field with uncorrelated components.</p>\n\n<p>png_field\n    Helper function to generate the full Non-Gaussian Field for a given PNG component.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>The 'ng_chisq' non-G component is uncorrelated to both 'zng1' and 'zng2'</p>\n"}, {"fullname": "modules.fields_nong.png_chisq", "modulename": "modules.fields_nong", "qualname": "png_chisq", "kind": "function", "doc": "<p>Generate Chi_e^2 Non-Gaussianity (only the FNG component, not the whole field) and return its correlated GRF too.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N : int\n    Number of grid points.\nAchi : float\n    Amplitude of the non-Gaussian component.\nRchi : float\n    Correlation length of the non-Gaussian component.\nBchi : float\n    Bias of the non-Gaussian component.\nFng : float\n    ???\nkmaxknyq_ratio : float\n    Fraction of the Nyquist frequency to use as the maximum wavenumber.\nseedchi : int\n    Seed for the random number generator.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ng_chisq : array\n    Non-Gaussian component of the field.\ngrf_chisq : array\n    Gaussian random field.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>from nate:\n    Achi = 1.6<em>10</em>*(-19)\n    Rchi = 0.64\n    Bchi = ?</p>\n\n<p>This makes the ng_chisq and grf_chisq fields correlated to each other.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">N</span>,</span><span class=\"param\">\t<span class=\"n\">Achi</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span>,</span><span class=\"param\">\t<span class=\"n\">Rchi</span><span class=\"o\">=</span><span class=\"mf\">0.04</span>,</span><span class=\"param\">\t<span class=\"n\">Bchi</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">Fng</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span>,</span><span class=\"param\">\t<span class=\"n\">seedchi</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_asymsinh", "modulename": "modules.fields_nong", "qualname": "png_asymsinh", "kind": "function", "doc": "<p>Generate Asymmetric Sinh Non-Gaussianity (only the FNG component, not the full NG field).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>zg : array\n    Gaussian random field.\nnu : float\n    ???\nalpha : float\n    ???\nc : float\n    ???\nw : float\n    ???</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ng_asymsinh : array\n    Non-Gaussian component of the field.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Note that 'zg' is the field used to generate the NG component called 'ng_asymsinh'. So the 'zng_asymsinh' is correlated with 'zg'.\nIn order to get uncorrelated 'png_asymsinh', provide a GRF 'zg' different from the one used for the actual Primordial Field Realization.\nThe final $\\zeta$ field will be generated depending on the choice of 'correlation' (or lack thereof).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zg</span>, </span><span class=\"param\"><span class=\"n\">nu</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mf\">0.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_map_asymsinh", "modulename": "modules.fields_nong", "qualname": "png_map_asymsinh", "kind": "function", "doc": "<p>Map a GRF to an Asymmetric $\\sinh$ Non-Gaussian component.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x\n    The input GRF\nw\n    The width of the distribution\nalpha\n    The power of the $\\sinh$ function</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>y\n    The value of y, which is the value of x if x is less than 0, and the value of w *\nkth_root(np.sinh((x / w)**alpha), alpha) if x is greater than 0.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.kth_root", "modulename": "modules.fields_nong", "qualname": "kth_root", "kind": "function", "doc": "<p>Return the kth root of x.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : float or array\n    The number/array of numbers to take the root of.\nn : float\n    The power of the root.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>array\n    The kth root of x.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Used in png_map_asymsinh above.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_field_chisq", "modulename": "modules.fields_nong", "qualname": "png_field_chisq", "kind": "function", "doc": "<p>Generate FINAL Primordial Zeta field with uncorrelated Chi_e^2 Non-Gaussianity.</p>\n\n<p>#</p>\n\n<h1 id=\"from-nate\">from nate:</h1>\n\n<h1 id=\"achi-1610-19\">Achi = 1.6<em>10</em>*(-19)</h1>\n\n<h1 id=\"rchi-064\">Rchi = 0.64</h1>\n\n<h1 id=\"bchi\">Bchi = ?</h1>\n\n<p>#</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">zg</span>,</span><span class=\"param\">\t<span class=\"n\">Achi</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span>,</span><span class=\"param\">\t<span class=\"n\">Rchi</span><span class=\"o\">=</span><span class=\"mf\">0.04</span>,</span><span class=\"param\">\t<span class=\"n\">Bchi</span><span class=\"o\">=</span><span class=\"mf\">0.0</span>,</span><span class=\"param\">\t<span class=\"n\">Fng</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span>,</span><span class=\"param\">\t<span class=\"n\">seedchi</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_field_asymsinh_corr", "modulename": "modules.fields_nong", "qualname": "png_field_asymsinh_corr", "kind": "function", "doc": "<p>Generate FINAL Primordial Zeta field with Correlated Asymmetric Sinh Non-Gaussianity.</p>\n\n<p>Note that 'zg' is the field used to generate the NG component called 'ng_asymsinh'. \nSo the 'zng_asymsinh' is correlated with 'zg'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zg</span>, </span><span class=\"param\"><span class=\"n\">nu</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mf\">0.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_field_asymsinh_uncorr", "modulename": "modules.fields_nong", "qualname": "png_field_asymsinh_uncorr", "kind": "function", "doc": "<p>Generate FINAL Primordial Zeta field with Uncorrelated Asymmetric Sinh Non-Gaussianity.</p>\n\n<p>Note that 'zg1' is the field used to generate the NG component called 'ng_asymsinh'. \nSo the 'zng_asymsinh' is correlated with 'zg1' but uncorrelated with 'zg2', a different Gaussian random field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zg1</span>, </span><span class=\"param\"><span class=\"n\">zg2</span>, </span><span class=\"param\"><span class=\"n\">nu</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mi\">2</span>, </span><span class=\"param\"><span class=\"n\">w</span><span class=\"o\">=</span><span class=\"mf\">0.2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.fields_nong.png_field", "modulename": "modules.fields_nong", "qualname": "png_field", "kind": "function", "doc": "<p>Generate Primordial field with generic non-Gaussianity/FNL.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">ng</span>, </span><span class=\"param\"><span class=\"n\">FNL</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters", "modulename": "modules.filters", "kind": "module", "doc": "<p>This module contains functions for filtering given fields with different window functions.</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>window_tophat(g, N, k_low, k_up)\n    Apply top hat window filter in k-space.\nwindow_hamm(g, N, k_low, k_high)\n    Apply Hamming window filter in k-space.\nwindow_hann(kbins)\n    Create Hann window filters in k-space.\nwindow_conv(gk, k, filt_win, kstart, kstop)\n    Helper function for applying a given window filter in k-space.</p>\n\n<p>filter_hann(g, nkbins=5, k_min=None, k_max=None, dc_comp=False)\n    Apply the Hann window filters in k-space for a given number of bins.\nfilterhann_ica(field_g, field_ng, \n            k_min=None, k_max=None, kmaxknyq_ratio=(2/3), nkbins=5, dc=False,\n                max_iter=1e4, tol=1e-5, fun='logcosh', whiten='unit-variance', algo='parallel', \n                    prewhiten = False, wbin_size = None)\n    Apply the Hann window filters in k-space for a given number of bins and perform ICA on the filtered fields.</p>\n\n<p>filterhat_gng(g_field, ng_field, size, k_low, k_high)\n    Apply top hat window filter in k-space for a given range of k-bins.\nfilterhat_ica(field_g, field_ng,\n            k_min=None, k_max=None, kmaxknyq_ratio=(2/3), nkbins=5, dc=False,\n                max_iter=1e4, tol=1e-5, fun='logcosh', whiten='unit-variance', algo='parallel',\n                    prewhiten = False, wbin_size = None)\n    Apply top hat window filter in k-space for a given range of k-bins and perform ICA on the filtered fields.</p>\n"}, {"fullname": "modules.filters.window_tophat", "modulename": "modules.filters", "qualname": "window_tophat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_low</span>, </span><span class=\"param\"><span class=\"n\">k_up</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.window_hamm", "modulename": "modules.filters", "qualname": "window_hamm", "kind": "function", "doc": "<p>Apply Hamming window filter in k-space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_low</span>, </span><span class=\"param\"><span class=\"n\">k_high</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.window_hann", "modulename": "modules.filters", "qualname": "window_hann", "kind": "function", "doc": "<p>Create Hann window filters in k-space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kbins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.window_conv", "modulename": "modules.filters", "qualname": "window_conv", "kind": "function", "doc": "<p>Apply window filter in k-space.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">gk</span>, </span><span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">filt_win</span>, </span><span class=\"param\"><span class=\"n\">kstart</span>, </span><span class=\"param\"><span class=\"n\">kstop</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.filter_hann", "modulename": "modules.filters", "qualname": "filter_hann", "kind": "function", "doc": "<p>Apply the Hann window filters in k-space for a given number of bins.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">nkbins</span><span class=\"o\">=</span><span class=\"mi\">5</span>, </span><span class=\"param\"><span class=\"n\">k_min</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">k_max</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dc_comp</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.filterhann_ica", "modulename": "modules.filters", "qualname": "filterhann_ica", "kind": "function", "doc": "<p>Apply ICA to Hann-filtered fields in k-space for a given number of bins.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field_g</span>,</span><span class=\"param\">\t<span class=\"n\">field_ng</span>,</span><span class=\"param\">\t<span class=\"n\">k_min</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">k_max</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">kmaxknyq_ratio</span><span class=\"o\">=</span><span class=\"mf\">0.6666666666666666</span>,</span><span class=\"param\">\t<span class=\"n\">nkbins</span><span class=\"o\">=</span><span class=\"mi\">5</span>,</span><span class=\"param\">\t<span class=\"n\">dc</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prewhiten</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">wbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.filterhat_gng", "modulename": "modules.filters", "qualname": "filterhat_gng", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g_field</span>, </span><span class=\"param\"><span class=\"n\">ng_field</span>, </span><span class=\"param\"><span class=\"n\">size</span>, </span><span class=\"param\"><span class=\"n\">k_low</span>, </span><span class=\"param\"><span class=\"n\">k_high</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.filters.filterhat_ica", "modulename": "modules.filters", "qualname": "filterhat_ica", "kind": "function", "doc": "<p>Top hat filtering.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">g</span>,</span><span class=\"param\">\t<span class=\"n\">ng</span>,</span><span class=\"param\">\t<span class=\"n\">klow</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">khigh</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">nbins</span><span class=\"o\">=</span><span class=\"mi\">10</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prewhiten</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">wbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d", "modulename": "modules.ica_1d", "kind": "module", "doc": "<p>This module contains functions for performing FastICA on 1D data along with pre-processing and post-processing steps.</p>\n\n<p>Below is a list of the functions in this module.</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>ica_setup(source_noise, source_nonG)\n    Set up signal mixture for ICA.\nica_prewhiten(mix_signal, kbin_size=None)\n    Custom prewhitening of the signal mixture in k-space.\nfastica_run(mix, num_comps, max_iter=1e4, tol=1e-5, \n        fun='logcosh', whiten='unit-variance', algo='parallel')\n    Run FastICA on the signal mixture.</p>\n\n<p>ica_match(source_comps, ica_comps)\n    Match the source components to the ICA components.\nica_scaleandsign(source_comps, ica_comps)\n    Scale and sign the ICA components to match the source components.\nica_scaleoffset(source_comps, ica_comps)\n    Scale and offset the ICA components to match the source components.\nica_swap(source_comps, ica_comps)\n    Swap the ICA components to match the source components.</p>\n\n<p>ica_all(field_g, field_ng, \n            max_iter=1e4, tol=1e-5, fun='logcosh', whiten='unit-variance', algo='parallel', \n                prewhiten = False, wbin_size = None)\n    Preprocess signals, run ICA, and perform postprocessing on the given fields.\nica_all_unknownmix(obs_signal, num_comps=None, \n            max_iter=1e5, tol=1e-5, fun='logcosh', whiten='unit-variance', algo='parallel', \n                prewhiten = False, wbin_size = None)\n    Preprocess signals, run ICA, and perform postprocessing on an apriori unknown mixture of signals.</p>\n\n<h2 id=\"notes\">Notes</h2>\n"}, {"fullname": "modules.ica_1d.ica_setup", "modulename": "modules.ica_1d", "qualname": "ica_setup", "kind": "function", "doc": "<p>Set up signal mixture for ICA.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>source_noise : array\n    GRF component of the signal mixture.\nsource_nonG : array\n    PNG component of the signal mixture.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>mix_signal : array\n    Mixed signal.\nsource_comps : array\n    Source components.\nnum_comps : int\n    Number of source components.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>source_noise    :   grf generated using gaussianfield [in Notebook Setup above]\nsource_nonG     :   returns n columns corresponding to n gaussian peaks that are shifted by xPeak/xc relative to 0 (and scaled by the size of the field)\nsource_comps    :   array of source component arrays\nnum_comps       :   num of different source signals/components, i.e. GRF &amp; no. of peaks\nnum_samples     :   num of observations (has to be &gt;= num_comps)\nmix_matrix      :   mixing matrix generated randomly with entries over [0.5, 1)\nmix_signal      :   resulting mixed/observed signals (not prewhitened)\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_noise</span>, </span><span class=\"param\"><span class=\"n\">source_nonG</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_prewhiten", "modulename": "modules.ica_1d", "qualname": "ica_prewhiten", "kind": "function", "doc": "<p>Custom prewhitening of the signal mixture in k-space.</p>\n\n<p>Handling the two observed signals separately. \nPreprocessing involves mean subtraction and dividing by the variance (in k-space).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mix_signal</span>, </span><span class=\"param\"><span class=\"n\">kbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.fastica_run", "modulename": "modules.ica_1d", "qualname": "fastica_run", "kind": "function", "doc": "<p>Initialize FastICA with given params.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>mix : np.ndarray, shape (n, m)\n    nxm numpy array containing the mixed/observed signals.\nnum_comps : int\n    Number of components to extract.\nmax_iter : int, optional\n    Maximum number of iterations to run FastICA. The default is 1e4.\ntol : float, optional\n    Tolerance for convergence. The default is 1e-5.\nfun : str, optional\n    Cost-function to use for ICA. The default is 'logcosh'.\nwhiten : str, optional\n    Whitening method to use. The default is 'unit-variance'.\nalgo : str, optional\n    Algorithm to use for ICA. The default is 'parallel'.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>sources.T : np.ndarray, shape (m, n)\n    mxn numpy array containing the extracted source components.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Logcosh is negentropy.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mix</span>,</span><span class=\"param\">\t<span class=\"n\">num_comps</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_match", "modulename": "modules.ica_1d", "qualname": "ica_match", "kind": "function", "doc": "<p>Swap, scale, and sign-invert the ICA components to match the source components.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>source_comps : np.ndarray, shape (2, n)\n    2xn numpy array containing the source components.\nica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ica_sources : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components with the scaled and inverted components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_scaleandsign", "modulename": "modules.ica_1d", "qualname": "ica_scaleandsign", "kind": "function", "doc": "<p>Scale and invert the sign of the ICA components to match the source components.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>source_comps : np.ndarray, shape (2, n)\n    2xn numpy array containing the source components.\nica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ica_sources : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components with the scaled and inverted components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_scaleoffset", "modulename": "modules.ica_1d", "qualname": "ica_scaleoffset", "kind": "function", "doc": "<p>Scale and offset the ICA components to match the source components.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>source_comps : np.ndarray, shape (2, n)\n    2xn numpy array containing the source components.\nica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ica_sources : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components with the scaled and offset components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_swap", "modulename": "modules.ica_1d", "qualname": "ica_swap", "kind": "function", "doc": "<p>Swap the ICA components to match the source components.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>source_comps : np.ndarray, shape (2, n)\n    2xn numpy array containing the source components.\nica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ica_sources : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components with the swapped components.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_all", "modulename": "modules.ica_1d", "qualname": "ica_all", "kind": "function", "doc": "<p>Preprocess signals, run ICA, and perform postprocessing on the given fields.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>field_g : np.ndarray, shape (n, m)\n    n x m numpy array containing the field data for the Gaussian source.\nfield_ng : np.ndarray, shape (n, m)\n    n x m numpy array containing the field data for the non-Gaussian source.\nmax_iter : int, optional\n    Maximum number of iterations to run ICA. The default is 1e4.\ntol : float, optional\n    Tolerance for ICA convergence. The default is 1e-5.\nfun : str, optional\n    The functional form of the G function used in the ICA algorithm. The default is 'logcosh'.\nwhiten : str, optional\n    The whitening method to use. The default is 'unit-variance'.\nalgo : str, optional\n    The algorithm to use. The default is 'parallel'.\nprewhiten : bool, optional\n    Whether to prewhiten the data before running ICA. The default is False.\nwbin_size : int, optional\n    The size of the bins to use for prewhitening. The default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>src : np.ndarray, shape (2, n)\n    2xn numpy array containing the source components.\nica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.\nsrc_max : np.ndarray, shape (2,)\n    2x1 numpy array containing the maximum values of the source components.\nica_max : np.ndarray, shape (2,)\n    2x1 numpy array containing the maximum values of the ICA components.\nmix_signal : np.ndarray, shape (2, n)\n    2xn numpy array containing the mixed signals.\nica_src_og : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components before postprocessing.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field_g</span>,</span><span class=\"param\">\t<span class=\"n\">field_ng</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prewhiten</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">wbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_1d.ica_all_unknownmix", "modulename": "modules.ica_1d", "qualname": "ica_all_unknownmix", "kind": "function", "doc": "<p>Preprocess signals, run ICA, and perform postprocessing on an apriori unknown mixture of signals.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>obs_signal : np.ndarray, shape (n, m)\n    n x m numpy array containing the observed signals.\nnum_comps : int, optional\n    The number of components to use. The default is None.\nmax_iter : int, optional\n    Maximum number of iterations to run ICA. The default is 1e5.\ntol : float, optional\n    Tolerance for ICA convergence. The default is 1e-5.\nfun : str, optional\n    The functional form of the G function used in the ICA algorithm. The default is 'logcosh'.\nwhiten : str, optional\n    The whitening method to use. The default is 'unit-variance'.\nalgo : str, optional\n    The algorithm to use. The default is 'parallel'.\nprewhiten : bool, optional\n    Whether to prewhiten the data before running ICA. The default is False.\nwbin_size : int, optional\n    The size of the bins to use for prewhitening. The default is None.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>ica_src : np.ndarray, shape (2, n)\n    2xn numpy array containing the ICA components.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">obs_signal</span>,</span><span class=\"param\">\t<span class=\"n\">num_comps</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">100000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prewhiten</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">wbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble", "modulename": "modules.ica_ensemble", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "modules.ica_ensemble.ica_setup", "modulename": "modules.ica_ensemble", "qualname": "ica_setup", "kind": "function", "doc": "<p>source_noise    :   grf generated using gaussianfield [in Notebook Setup above]\nsource_nonG     :   returns n columns corresponding to n gaussian peaks that are shifted by xPeak/xc relative to 0 (and scaled by the size of the field)</p>\n\n<p>source_comps    :   array of source component arrays\nnum_comps       :   num of different source signals/components, i.e. GRF &amp; no. of peaks\nnum_samples     :   num of observations (has to be &gt;= num_comps)\nmix_matrix      :   mixing matrix generated randomly with entries over [0.5, 1)\nmix_signal      :   resulting mixed/observed signals (not prewhitened)</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_noise</span>, </span><span class=\"param\"><span class=\"n\">source_nonG</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_prewhiten", "modulename": "modules.ica_ensemble", "qualname": "ica_prewhiten", "kind": "function", "doc": "<p>Handling the two observed signals separately. \nPreprocessing involves mean subtraction and dividing by the variance (in k-space).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">mix_signal</span>, </span><span class=\"param\"><span class=\"n\">kbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.fastica_run", "modulename": "modules.ica_ensemble", "qualname": "fastica_run", "kind": "function", "doc": "<p>Initialize FastICA with given params.</p>\n\n<p>Notes:\n        Logcosh is negentropy.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">mix</span>,</span><span class=\"param\">\t<span class=\"n\">num_comps</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_swap", "modulename": "modules.ica_ensemble", "qualname": "ica_swap", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_scaleoffset", "modulename": "modules.ica_ensemble", "qualname": "ica_scaleoffset", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_scaleandsign", "modulename": "modules.ica_ensemble", "qualname": "ica_scaleandsign", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_restore", "modulename": "modules.ica_ensemble", "qualname": "ica_restore", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">source_comps</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.ica_ensemble.ica_all", "modulename": "modules.ica_ensemble", "qualname": "ica_all", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">field_g</span>,</span><span class=\"param\">\t<span class=\"n\">field_ng</span>,</span><span class=\"param\">\t<span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mf\">10000.0</span>,</span><span class=\"param\">\t<span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-05</span>,</span><span class=\"param\">\t<span class=\"n\">fun</span><span class=\"o\">=</span><span class=\"s1\">&#39;logcosh&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">whiten</span><span class=\"o\">=</span><span class=\"s1\">&#39;unit-variance&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">algo</span><span class=\"o\">=</span><span class=\"s1\">&#39;parallel&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">prewhiten</span><span class=\"o\">=</span><span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">wbin_size</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields", "modulename": "modules.init_fields", "kind": "module", "doc": "<p>Imports Peak-Patch fields as NumPy arrays.</p>\n\n<p>@Authors:   Jibran Haider &amp; Nathan Carlson</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>I'm currently setup to run in terminal with a command::</p>\n\n<pre><code>$ python3\n</code></pre>\n\n<p>Or you can run me in a .ipynb notebook with::</p>\n\n<pre><code>%run\n</code></pre>\n\n<p>Or you can import me as a module::</p>\n\n<pre><code>import\n</code></pre>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>delta : </p>\n\n<p>delta_g : </p>\n\n<p>delta_ng : </p>\n\n<p>zeta : </p>\n\n<p>zeta_g : </p>\n\n<p>zeta_ng : </p>\n\n<p>X : </p>\n\n<p>Y : </p>\n\n<p>Z : </p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Example Peak-Patch realization: \n    peak-patch-runs/n1024bigR/z2/fnl1e6/\n    New runs: \n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/ng7_test_oct6\n                Then there\u2019s 3D fields in the \u201cfields\" subdirectory, and there\u2019s 2D healpix maps in the \u201cmaps\" subdirectory, you can play with those with python using healpy.\n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/s4k_n236_nb20_nt10_ng6_nside2048/fnl5e3/</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Write necessary code to be able to turn Delta fields processing on or off.</p>\n"}, {"fullname": "modules.init_fields.import_params", "modulename": "modules.init_fields", "qualname": "import_params", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lmpc</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">larray</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lbuff</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_delta", "modulename": "modules.init_fields", "qualname": "get_delta", "kind": "function", "doc": "<p>Import total Delta field (G + nonG).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_delta_g", "modulename": "modules.init_fields", "qualname": "get_delta_g", "kind": "function", "doc": "<p>Import Gaussian component of Delta field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_delta_ng", "modulename": "modules.init_fields", "qualname": "get_delta_ng", "kind": "function", "doc": "<p>Import nonG component of Delta (delta - delta_g = delta_ng).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">delta</span>, </span><span class=\"param\"><span class=\"n\">delta_g</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_delta_all", "modulename": "modules.init_fields", "qualname": "get_delta_all", "kind": "function", "doc": "<p>Import Delta fields</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">d_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">dg_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_zeta", "modulename": "modules.init_fields", "qualname": "get_zeta", "kind": "function", "doc": "<p>Import total Zeta field (G + nonG).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_zeta_g", "modulename": "modules.init_fields", "qualname": "get_zeta_g", "kind": "function", "doc": "<p>Import Gaussian component of Zeta field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_zeta_ng", "modulename": "modules.init_fields", "qualname": "get_zeta_ng", "kind": "function", "doc": "<p>Import nonG component of Zeta (zeta - zeta_g = zeta_ng).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">zeta</span>, </span><span class=\"param\"><span class=\"n\">zeta_g</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_zeta_all", "modulename": "modules.init_fields", "qualname": "get_zeta_all", "kind": "function", "doc": "<p>Import Zeta fields</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">z_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">zg_file_name</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.get_meshgrid", "modulename": "modules.init_fields", "qualname": "get_meshgrid", "kind": "function", "doc": "<p>Initialize a meshgrid.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">field_side_mpc</span>, </span><span class=\"param\"><span class=\"n\">array_side</span><span class=\"p\">:</span> <span class=\"nb\">int</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.init_fields.main", "modulename": "modules.init_fields", "qualname": "main", "kind": "function", "doc": "<p>Main function.</p>\n\n<p>TODO:\n    Write necessary code to be able to turn Delta fields processing on or off.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lengths</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">isDelta</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar", "modulename": "modules.jaafar", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "modules.jaafar.jaafar_colorednoise", "modulename": "modules.jaafar.jaafar_colorednoise", "kind": "module", "doc": "<p>Generate colored noise.\nCopyright (c) 2014-2017 Felix Patzelt</p>\n"}, {"fullname": "modules.jaafar.jaafar_colorednoise.powerlaw_psd_gaussian", "modulename": "modules.jaafar.jaafar_colorednoise", "qualname": "powerlaw_psd_gaussian", "kind": "function", "doc": "<p>Gaussian (1/f)**beta noise.\nBased on the algorithm in:\nTimmer, J. and Koenig, M.:\nOn generating power law noise.\nAstron. Astrophys. 300, 707-710 (1995)\nNormalised to unit variance</p>\n\n<h2 id=\"parameters\">Parameters:</h2>\n\n<p>exponent : float\n    The power-spectrum of the generated noise is proportional to\n    S(f) = (1 / f)<strong>beta\n    flicker / pink noise:   exponent beta = 1\n    brown noise:            exponent beta = 2\n    Furthermore, the autocorrelation decays proportional to lag</strong>-gamma\n    with gamma = 1 - beta for 0 &lt; beta &lt; 1.\n    There may be finite-size issues for beta close to one.\nshape : int or iterable\n    The output has the given shape, and the desired power spectrum in\n    the last coordinate. That is, the last dimension is taken as time,\n    and all other components are independent.\nfmin : float, optional\n    Low-frequency cutoff.\n    Default: 0 corresponds to original paper. It is not actually\n    zero, but 1/samples.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>out : array\n    The samples.</p>\n\n<h2 id=\"examples\">Examples:</h2>\n\n<h1 id=\"generate-1f-noise-pink-noise-flicker-noise\">generate 1/f noise == pink noise == flicker noise</h1>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"gp\">&gt;&gt;&gt; </span><span class=\"kn\">import</span> <span class=\"nn\">colorednoise</span> <span class=\"k\">as</span> <span class=\"nn\">cn</span>\n<span class=\"gp\">&gt;&gt;&gt; </span><span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">cn</span><span class=\"o\">.</span><span class=\"n\">powerlaw_psd_gaussian</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span>\n</code></pre>\n</div>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">exponent</span>, </span><span class=\"param\"><span class=\"n\">size</span>, </span><span class=\"param\"><span class=\"n\">fmin</span><span class=\"o\">=</span><span class=\"mi\">0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions", "modulename": "modules.jaafar.jaafar_correlationfunctions", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.get_bins", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "get_bins", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">num</span>, </span><span class=\"param\"><span class=\"n\">grid</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.get_binweights", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "get_binweights", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">grid</span>, </span><span class=\"param\"><span class=\"n\">numbins</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.field_average", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "field_average", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">ind</span>, </span><span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">sumweights</span>, </span><span class=\"param\"><span class=\"n\">oneD</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.angular_average", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "angular_average", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">kgrid</span>, </span><span class=\"param\"><span class=\"n\">nbins</span>, </span><span class=\"param\"><span class=\"n\">oneD</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.power_spectrum", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "power_spectrum", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x1</span>, </span><span class=\"param\"><span class=\"n\">x2</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">oneD</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.k_kurtosis", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "k_kurtosis", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">nbins</span><span class=\"o\">=</span><span class=\"mi\">60</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.k_skewness", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "k_skewness", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">nbins</span><span class=\"o\">=</span><span class=\"mi\">60</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.cdf", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "cdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.pdf", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "pdf", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.skewness", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "skewness", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_correlationfunctions.kurtosis", "modulename": "modules.jaafar.jaafar_correlationfunctions", "qualname": "kurtosis", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters", "modulename": "modules.jaafar.jaafar_filters", "kind": "module", "doc": "<p>// Created by Jaafar.\nModified by Jibran Haider. //</p>\n"}, {"fullname": "modules.jaafar.jaafar_filters.window_tophat", "modulename": "modules.jaafar.jaafar_filters", "qualname": "window_tophat", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">f</span>, </span><span class=\"param\"><span class=\"n\">kmin</span>, </span><span class=\"param\"><span class=\"n\">kmax</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.window_gauss_log", "modulename": "modules.jaafar.jaafar_filters", "qualname": "window_gauss_log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_center</span>, </span><span class=\"param\"><span class=\"n\">k_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.window_gauss_norm", "modulename": "modules.jaafar.jaafar_filters", "qualname": "window_gauss_norm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_center</span>, </span><span class=\"param\"><span class=\"n\">k_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.window_gauss", "modulename": "modules.jaafar.jaafar_filters", "qualname": "window_gauss", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_center</span>, </span><span class=\"param\"><span class=\"n\">k_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.filter_profile", "modulename": "modules.jaafar.jaafar_filters", "qualname": "filter_profile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.ft_filter_profile", "modulename": "modules.jaafar.jaafar_filters", "qualname": "ft_filter_profile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">kx</span>, </span><span class=\"param\"><span class=\"n\">ky</span>, </span><span class=\"param\"><span class=\"n\">kz</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_filters.filter_field", "modulename": "modules.jaafar.jaafar_filters", "qualname": "filter_field", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">rf</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_fouriertransform", "modulename": "modules.jaafar.jaafar_fouriertransform", "kind": "module", "doc": "<p>// Created by Jaafar.\nModified by Jibran Haider &amp; Tom Morrison. //</p>\n\n<p><strong>Contains the following functions</strong></p>\n\n<p>fftmodes(N, BoxSize=None):\nfft(x, BoxSize=1.0, modes=False, grid=False, oneD=False):\nifft(x, BoxSize=1.0):</p>\n"}, {"fullname": "modules.jaafar.jaafar_fouriertransform.fftmodes", "modulename": "modules.jaafar.jaafar_fouriertransform", "qualname": "fftmodes", "kind": "function", "doc": "<p>RETURNS:</p>\n\n<p>np.fft.fftshift(np.fft.fftfreq(N))  IF  no BoxSize given</p>\n\n<p>OR</p>\n\n<p>np.fft.fftshift(np.fft.fftfreq(N)) * (N/BoxSize)  IF  BoxSize is given \n(this just corrects the frequencies to match the intended, physical size of the box instead of N)</p>\n\n<p>np.fft() is numpy's discrete fast fourier transform.\nnp.fft.fftfreq() returns the Discrete Fourier Transform sample frequencies \n[where you can provide the sample spacing, i.e. BoxSize/N in this case.]\nnp.fft.fftshift() shifts the zero-frequency component to the center of the spectrum.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_fouriertransform.fft", "modulename": "modules.jaafar.jaafar_fouriertransform", "qualname": "fft", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">modes</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">grid</span><span class=\"o\">=</span><span class=\"kc\">False</span>, </span><span class=\"param\"><span class=\"n\">oneD</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_fouriertransform.ifft", "modulename": "modules.jaafar.jaafar_fouriertransform", "qualname": "ifft", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield", "modulename": "modules.jaafar.jaafar_gaussianfield", "kind": "module", "doc": "<p>JAAFAR: Generate Gaussian Fields.\n// Created by Jaafar.\nModified by Jibran Haider &amp; Tom Morrison. //</p>\n\n<p><strong>Contains the following functions</strong></p>\n\n<p>gauss_var(size, seed=None):\npower_array(Pk, k):\npower_array_new(k, amp, tilt=1):\ngaussian_random_field(N, BoxSize=1.0, seed=None, Pk=lambda k: k**-3):\ngaussian_random_field_1D(N, BoxSize=1.0, seed=None):\nwindow(g, N, k_low, k_up):\nwindow_gauss_log(g, N, k_center, k_width):\nwindow_gauss_norm(g, N, k_center, k_width):</p>\n"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.gauss_var", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "gauss_var", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">size</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.power_array", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "power_array", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">Pk</span>, </span><span class=\"param\"><span class=\"n\">k</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.power_array_new", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "power_array_new", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">k</span>, </span><span class=\"param\"><span class=\"n\">amp</span>, </span><span class=\"param\"><span class=\"n\">tilt</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.gaussian_random_field", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "gaussian_random_field", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">Pk</span><span class=\"o\">=&lt;</span><span class=\"n\">function</span> <span class=\"o\">&lt;</span><span class=\"k\">lambda</span><span class=\"o\">&gt;&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.gaussian_random_field_1D", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "gaussian_random_field_1D", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">BoxSize</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.window", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "window", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_low</span>, </span><span class=\"param\"><span class=\"n\">k_up</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.window_gauss_log", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "window_gauss_log", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_center</span>, </span><span class=\"param\"><span class=\"n\">k_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_gaussianfield.window_gauss_norm", "modulename": "modules.jaafar.jaafar_gaussianfield", "qualname": "window_gauss_norm", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">g</span>, </span><span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">k_center</span>, </span><span class=\"param\"><span class=\"n\">k_width</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks", "modulename": "modules.jaafar.jaafar_peaks", "kind": "module", "doc": "<p>JAAFAR: Generate Peaks as Non-Gaussianity.\n// Created by Jaafar.\nModified by Jibran Haider &amp; Tom Morrison. //</p>\n\n<p><strong>Contains the following functions</strong></p>\n"}, {"fullname": "modules.jaafar.jaafar_peaks.kth_root", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "kth_root", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">n</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.map_sinh", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "map_sinh", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">w</span>, </span><span class=\"param\"><span class=\"n\">alpha</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.map_bypart", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "map_bypart", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">xp</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.map_bump", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "map_bump", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">z1</span>, </span><span class=\"param\"><span class=\"n\">z2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.map_smooth_bump", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "map_smooth_bump", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">c</span>, </span><span class=\"param\"><span class=\"n\">a</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.sq_ng", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "sq_ng", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">f_nl</span>, </span><span class=\"param\"><span class=\"n\">s2</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.peak_profile", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "peak_profile", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">z</span>, </span><span class=\"param\"><span class=\"n\">a</span>, </span><span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.add_peaks", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "add_peaks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">X</span>, </span><span class=\"param\"><span class=\"n\">L</span>, </span><span class=\"param\"><span class=\"n\">size</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jaafar.jaafar_peaks.draw_peaks", "modulename": "modules.jaafar.jaafar_peaks", "qualname": "draw_peaks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">nop</span>, </span><span class=\"param\"><span class=\"n\">size</span>, </span><span class=\"param\"><span class=\"n\">zp</span>, </span><span class=\"param\"><span class=\"n\">rp</span>, </span><span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica", "modulename": "modules.jonathan_fastica", "kind": "module", "doc": "<p></p>\n"}, {"fullname": "modules.jonathan_fastica.center", "modulename": "modules.jonathan_fastica", "qualname": "center", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.covariance", "modulename": "modules.jonathan_fastica", "qualname": "covariance", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.whiten", "modulename": "modules.jonathan_fastica", "qualname": "whiten", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.fastICA", "modulename": "modules.jonathan_fastica", "qualname": "fastICA", "kind": "function", "doc": "<p>Assumes signal has had mean removed and has been prewhitened</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">signals</span>, </span><span class=\"param\"><span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mi\">1</span>, </span><span class=\"param\"><span class=\"n\">thresh</span><span class=\"o\">=</span><span class=\"mf\">1e-08</span>, </span><span class=\"param\"><span class=\"n\">maxIt</span><span class=\"o\">=</span><span class=\"mi\">100</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.extract_peak_and_wave", "modulename": "modules.jonathan_fastica", "qualname": "extract_peak_and_wave", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">aPeak</span>,</span><span class=\"param\">\t<span class=\"n\">aWave</span>,</span><span class=\"param\">\t<span class=\"n\">wPeak</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">wWave</span><span class=\"o\">=</span><span class=\"mf\">1.0</span>,</span><span class=\"param\">\t<span class=\"n\">noise</span><span class=\"o\">=&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">method</span> <span class=\"n\">normal</span> <span class=\"n\">of</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">mtrand</span><span class=\"o\">.</span><span class=\"n\">RandomState</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.extract_peaks", "modulename": "modules.jonathan_fastica", "qualname": "extract_peaks", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_samples</span>,</span><span class=\"param\">\t<span class=\"n\">num_components</span>,</span><span class=\"param\">\t<span class=\"n\">aPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">wPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">noise</span><span class=\"o\">=&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">method</span> <span class=\"n\">normal</span> <span class=\"n\">of</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">mtrand</span><span class=\"o\">.</span><span class=\"n\">RandomState</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">ns</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.extract_peaks_nn", "modulename": "modules.jonathan_fastica", "qualname": "extract_peaks_nn", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_samples</span>,</span><span class=\"param\">\t<span class=\"n\">num_components</span>,</span><span class=\"param\">\t<span class=\"n\">aPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">wPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">noise</span><span class=\"o\">=&lt;</span><span class=\"n\">built</span><span class=\"o\">-</span><span class=\"ow\">in</span> <span class=\"n\">method</span> <span class=\"n\">normal</span> <span class=\"n\">of</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">mtrand</span><span class=\"o\">.</span><span class=\"n\">RandomState</span> <span class=\"nb\">object</span><span class=\"o\">&gt;</span>,</span><span class=\"param\">\t<span class=\"n\">ns</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.extract_peaks_nn_g", "modulename": "modules.jonathan_fastica", "qualname": "extract_peaks_nn_g", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">num_samples</span>,</span><span class=\"param\">\t<span class=\"n\">num_components</span>,</span><span class=\"param\">\t<span class=\"n\">aPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">xPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mf\">5.0</span><span class=\"p\">,</span> <span class=\"mf\">5.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">wPeak</span><span class=\"o\">=</span><span class=\"p\">[</span><span class=\"mf\">1.0</span><span class=\"p\">,</span> <span class=\"mf\">1.0</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">g</span><span class=\"o\">=</span><span class=\"mi\">0</span>,</span><span class=\"param\">\t<span class=\"n\">ns</span><span class=\"o\">=</span><span class=\"mi\">1000</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.plot_ica", "modulename": "modules.jonathan_fastica", "qualname": "plot_ica", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.jonathan_fastica.kurtosis", "modulename": "modules.jonathan_fastica", "qualname": "kurtosis", "kind": "function", "doc": "<p>Compute kurtosis of a signal</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">s</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params", "modulename": "modules.sim_params", "kind": "module", "doc": "<p>Imports relevant Peak-Patch parameters for a given field.</p>\n\n<p>@Authors:   Jibran Haider</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>TESTI'm currently setup to run in terminal with a command::</p>\n\n<pre><code>$ python3 get_params.py\n</code></pre>\n\n<p>Or you can run me in a .ipynb notebook with::</p>\n\n<pre><code>%run get_params.py\n</code></pre>\n\n<p>Or you can import me as a module::</p>\n\n<pre><code>import get_params\n</code></pre>\n\n<p>Or you can import relevant attributes (variables) using::</p>\n\n<pre><code>from get_params import ...\n</code></pre>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<p>fields_path : </p>\n\n<p>l_array : </p>\n\n<p>l_mpc : </p>\n\n<p>l_buff : </p>\n\n<p>l_trim : </p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>TODO: In final implementation, will have to take path to ppatch runs as input.</p>\n\n<p>Example Peak-Patch realization: \n    peak-patch-runs/n1024bigR/z2/fnl1e6/\n    New runs: \n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/ng7_test_oct6\n                Then there\u2019s 3D fields in the \u201cfields\" subdirectory, and there\u2019s 2D healpix maps in the \u201cmaps\" subdirectory, you can play with those with python using healpy.\n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/s4k_n236_nb20_nt10_ng6_nside2048/fnl5e3/</p>\n"}, {"fullname": "modules.sim_params.set_path_realization", "modulename": "modules.sim_params", "qualname": "set_path_realization", "kind": "function", "doc": "<p>Set the path to a given Peak-Patch realization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.get_path_realization", "modulename": "modules.sim_params", "qualname": "get_path_realization", "kind": "function", "doc": "<p>Get the stored path to a Peak-Patch realization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.input_path_realization", "modulename": "modules.sim_params", "qualname": "input_path_realization", "kind": "function", "doc": "<p>Take user-input for the path to a given Peak-Patch realization.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.get_path_params", "modulename": "modules.sim_params", "qualname": "get_path_params", "kind": "function", "doc": "<p>Get path to parameters' file (named 'param.params' in pkpatch).</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.get_path_fields", "modulename": "modules.sim_params", "qualname": "get_path_fields", "kind": "function", "doc": "<p>Get path to fields' dir.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.load_module", "modulename": "modules.sim_params", "qualname": "load_module", "kind": "function", "doc": "<p>This piece of code loads the parameters file, param.params. </p>\n\n<p>Needed to do it this way because of multiple subdirectories in the tree and the period/dot in the name \"param.params\".\nWould have had to create __init__.py files in each subdir otherwise.</p>\n\n<p>Got it from: \n<a href=\"https://csatlas.com/python-import-file-module/#import_any_file_including_non_py_file_extension_python_3_4_and_up\">https://csatlas.com/python-import-file-module/#import_any_file_including_non_py_file_extension_python_3_4_and_up</a></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_params</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.set_module_name", "modulename": "modules.sim_params", "qualname": "set_module_name", "kind": "function", "doc": "<p>Save the 'params' module with its full name containing most important params.</p>\n\n<p>sys.modules[] saves the module \"params\" with its full name containing the most imp. params.\nThis allows importing \"params\" directly with the full name.\nThe full name is \"SideLengthInMpc_SideLengthOfArray_BufferThickness_?\".</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">parameters</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.get_params", "modulename": "modules.sim_params", "qualname": "get_params", "kind": "function", "doc": "<p>Import relevant parameters needed.</p>\n\n<h2 id=\"returns\">Returns:</h2>\n\n<p>boxsize : \n    Side length of the cubic simulation volume (Mpc/h)\nnmesh : int\n    Side length of field array (pixels/array units)\nnbuff : int\n    Buffer thickness (pixels/array units)</p>\n\n<p><em>Note on Mpc/h:\nAn indeterminate unit of distance between 4/3 Mpc and 2 Mpc. \nThe h is a parameter in the closed interval [0.5, 0.75] and reflects an uncertainty in the Hubble constant. \nFor example, in a universe where the Hubble constant is 70km/Mpc/s, h is 0.7. \nSimilarly, a Hubble constant of 50km/Mpc/s would lead to a value for h of 0.5.</em></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">save_module</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.sim_params.main", "modulename": "modules.sim_params", "qualname": "main", "kind": "function", "doc": "<p>Main function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">path_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>, </span><span class=\"param\"><span class=\"n\">save_module</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields", "modulename": "modules.slicer_fields", "kind": "module", "doc": "<p>Slices 1D strips from a given realization of 3D Peak-Patch fields.</p>\n\n<p>@Authors:   Jibran Haider &amp; Nathan Carlson</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<p>TEST I'm currently setup to run in terminal with a command::</p>\n\n<pre><code>$ python3 slicer_1d.py\n</code></pre>\n\n<p>Or you can run me in a .ipynb notebook with::</p>\n\n<pre><code>%run slicer_1d.py\n</code></pre>\n\n<p>Or you can import me as a module::</p>\n\n<pre><code>import slicer_1d\n</code></pre>\n\n<h2 id=\"attributes\">Attributes</h2>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Example Peak-Patch realization: \n    peak-patch-runs/n1024bigR/z2/fnl1e6/\n    New runs: \n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/ng7_test_oct6\n                Then there\u2019s 3D fields in the \u201cfields\" subdirectory, and there\u2019s 2D healpix maps in the \u201cmaps\" subdirectory, you can play with those with python using healpy.\n            /mnt/scratch-lustre/njcarlson/peak-patch-runs/s4k_n236_nb20_nt10_ng6_nside2048/fnl5e3/</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Write necessary code to be able to turn Delta fields processing on or off.</p>\n"}, {"fullname": "modules.slicer_fields.Slicer1D", "modulename": "modules.slicer_fields", "qualname": "Slicer1D", "kind": "class", "doc": "<p>1D slicer object for a given initial fields realization.</p>\n\n<p>Attributes:\n    self.idx_seed (int) : Reseed the MT19937 BitGenerator.\n    self.path_pkp_realization (str | Path) : Path to initial fields realization\n    self.fields_3d (list) : Full 3D initial fields.\n    self.side_length (int) : Side length of the box after trimming off the buffers.</p>\n"}, {"fullname": "modules.slicer_fields.Slicer1D.__init__", "modulename": "modules.slicer_fields", "qualname": "Slicer1D.__init__", "kind": "function", "doc": "<p>Initialise 1D slicer object for a given initial fields realization.</p>\n\n<p>Input:\n    path_pkp_realization (str | Path) : Path to initial fields realization\n    idx_seed : Seed for the MT19937 BitGenerator.\n    fields_3d : Full 3D initial fields\n    is_rand_axes :</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">idx_seed</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">path_pkp_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fields_3d</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">isDelta</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "modules.slicer_fields.Slicer1D.set_seed", "modulename": "modules.slicer_fields", "qualname": "Slicer1D.set_seed", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">seed</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.Slicer1D.slice_1d", "modulename": "modules.slicer_fields", "qualname": "Slicer1D.slice_1d", "kind": "function", "doc": "<p>Extract 1D strips from the 3D fields.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>field_3d : list\n    3D fields from which to extract a 1D strip.\nindices : tuple\n    List of indices to slice 3D field-array with.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fields_1d : list\n    1D strips corresponding to list of 3D fields in 'field_3d'.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.Slicer1D.idx_rand_slice", "modulename": "modules.slicer_fields", "qualname": "Slicer1D.idx_rand_slice", "kind": "function", "doc": "<p>Generate random indices to take 1D slice from 3D field.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>idx_seed : int\n    Reseed the MT19937 BitGenerator.\nis_rand_axes : bool\n    Whether to randomize axes or not. Defaults to True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>coords : tuple\n    List of indices to slice 3D field-array with.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.Slicer2D", "modulename": "modules.slicer_fields", "qualname": "Slicer2D", "kind": "class", "doc": "<p>2D slicer object for a given initial fields realization.</p>\n\n<p>Attributes:\n    self.idx_seed (int) : Reseed the MT19937 BitGenerator.\n    self.path_pkp_realization (str | Path) : Path to initial fields realization\n    self.fields_3d (list) : Full 3D initial fields.\n    self.side_length (int) : Side length of the box after trimming off the buffers.</p>\n"}, {"fullname": "modules.slicer_fields.Slicer2D.__init__", "modulename": "modules.slicer_fields", "qualname": "Slicer2D.__init__", "kind": "function", "doc": "<p>Initialise 2D slicer object for a given initial fields realization.</p>\n\n<p>Input:\n    path_pkp_realization (str | Path) : Path to initial fields realization\n    idx_seed : Seed for the MT19937 BitGenerator.\n    fields_3d : Full 3D initial fields\n    is_rand_axes :</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">idx_seed</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">path_pkp_realization</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"n\">pathlib</span><span class=\"o\">.</span><span class=\"n\">Path</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">lengths</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">fields_3d</span><span class=\"p\">:</span> <span class=\"nb\">list</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">isDelta</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span></span>)</span>"}, {"fullname": "modules.slicer_fields.Slicer2D.set_seed", "modulename": "modules.slicer_fields", "qualname": "Slicer2D.set_seed", "kind": "function", "doc": "<p></p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">seed</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.Slicer2D.slice_2d", "modulename": "modules.slicer_fields", "qualname": "Slicer2D.slice_2d", "kind": "function", "doc": "<p>Extract 1D strips from the 3D fields.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>field_3d : list\n    3D fields from which to extract a 1D strip.\nindices : tuple\n    List of indices to slice 3D field-array with.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>fields_1d : list\n    1D strips corresponding to list of 3D fields in 'field_3d'.</p>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>Write necessary code to be able to turn Delta fields processing on or off.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">isDelta</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.Slicer2D.idx_rand_slice", "modulename": "modules.slicer_fields", "qualname": "Slicer2D.idx_rand_slice", "kind": "function", "doc": "<p>Generate random indices to take 2D slice from 3D field.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>idx_seed : int\n    Reseed the MT19937 BitGenerator.\nis_rand_axes : bool\n    Whether to randomize axes or not. Defaults to True.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>coords : tuple\n    List of indices to slice 3D field-array with.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">is_rand_axes</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.slicer_fields.main", "modulename": "modules.slicer_fields", "qualname": "main", "kind": "function", "doc": "<p>Main function.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">seed</span><span class=\"o\">=</span><span class=\"kc\">None</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d", "modulename": "modules.validate_1d", "kind": "module", "doc": "<p>Validation/accuracy analysis functions for 1D ICA.</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>calculate_all_metrics(true_field, extracted_field, round=None, is_print=True, norm=True, relative=True)\n    Calculate and print all metrics in validate_1d.py for a pair of fields.\ncalculate_residuals_ica(x, y, norm=True, relative=True)\n    Compute both scalar &amp; vector residuals between $x$ &amp; $y$, where $x$ is the source field and $y$ is the estimated field.\ntest_calculate_residuals_ica()\n    Test the calculate_residuals_ica() function.\ntest_calc_resid_ica()\n    Test the calculate_residuals_ica() function.\ncalculate_residuals(x, y, norm=True, relative=True)\n    Compute both scalar &amp; vector residuals between $x$ &amp; $y$.\ntest_calculate_residuals()\n    Test the calculate_residuals() function.\ncalculate_pearson_coefficient(src_field, est_field)\n    Calculate the Pearson correlation coefficient between the source field and the estimated field.\nbiweight_midcorrelation(x, y)\n    Calculate the biweight midcorrelation between the source field and the estimated field.\nrescale_extracted_field(true_field, extracted_field)\n    Rescale the extracted field to match the true field.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<h2 id=\"notes\">Notes</h2>\n"}, {"fullname": "modules.validate_1d.calculate_all_metrics", "modulename": "modules.validate_1d", "qualname": "calculate_all_metrics", "kind": "function", "doc": "<p>Calculate and print all metrics in validate_1d.py for a pair of fields.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true_field : np.ndarray\n    The true field.\nextracted_field : np.ndarray\n    The extracted field.\nround : int, optional\n    The number of decimal places to round the metrics to. If None, no rounding is performed.\nprint : bool, optional\n    If True, print all metrics. If False, do not print any metrics.\nnorm : bool, optional\n    If True, normalize the fields before calculating the residuals. If False, do not normalize the fields.\nrelative : bool, optional\n    If True, calculate the relative residuals. If False, calculate the absolute residuals.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>metrics : dict\n    A dictionary containing all metrics for the two fields.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">true_field</span>,</span><span class=\"param\">\t<span class=\"n\">extracted_field</span>,</span><span class=\"param\">\t<span class=\"nb\">round</span><span class=\"o\">=</span><span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">is_print</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">relative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.calculate_residuals_ica", "modulename": "modules.validate_1d", "qualname": "calculate_residuals_ica", "kind": "function", "doc": "<p>Compute both scalar &amp; vector residuals between $x$ &amp; $y$, where $x$ is the source field and $y$ is the estimated field.</p>\n\n<p>Scalar residual $r$ is defined as:\n    $r_s = 1 - \\frac{\\left\\|a\\right\\|_2}{\\left\\|b\\right\\|_2}$\nVector residual $r_v$ is defined as:\n    $r_v = 1 - \\frac{\\left\\|a\\right\\|_2}{\\left\\|b\\right\\|_2}$\nwhere $\\left\\|a\\right\\|_2$ is the 2-norm of $x$ and $\\left\\|b\\right\\|_2$ is the 2-norm of $y$.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.ndarray\n    True field $x$. Must be same shape as $y$.\ny : np.ndarray\n    Extracted field $y$. Must be same shape as $x$.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>rs : float\n    Scalar residual of $x$ and $y$ (see below).\nrv : np.ndarray\n    Vector residual of $x$ and $y$ (see below).</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>(1) Normalize vector y by mean-subtraction and standard deviation-division, then rescale it by the standard deviation of x. \nThis step ensures that y has the same mean and scale as x, which is essential for a fair comparison.\n\n(2) The vector residual (rv) is calculated by projecting the rescaled y vector onto the x vector, then dividing the result by the magnitude of the x vector. \nThis measures how well y aligns with x, considering both direction and magnitude.\nThe vector residual ($rv$) is calculated as:\n    rv = 1 - ( ( b.a / a.a ) * a ) / |a|\n\n(3) The scalar residual (rs) is calculated by finding the magnitude of the projection of y onto x, dividing it by the square of the magnitude of x, and subtracting the result from 1. \nThis measures the absolute difference between the magnitudes of: x AND the projection of y onto x.\nThe scalar residual ($rr$) is calculated as:\n    rs = 1 - | ( b.a / |a| ) / |a| |\n\n\nNote that the magnitude of x is:\n    |x| = (x.x)^{1/2}\nwhere $x$ is a vector.\n</code></pre>\n\n<h2 id=\"todo\">TODO</h2>\n\n<p>FILL IN WHY IT MAKES SENSE TO CHOOSE TO COMPUTE $RV$ &amp; $RR$ THIS WAY!</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">relative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.test_calculate_residuals_ica", "modulename": "modules.validate_1d", "qualname": "test_calculate_residuals_ica", "kind": "function", "doc": "<p>Test calculate_residuals_ica() function.</p>\n\n<p>This test function checks three different cases:</p>\n\n<p>Identical vectors: The scalar residual should be 1, and the vector residual should be equal to the original vector a.</p>\n\n<p>Opposite vectors: The scalar residual should be -1, and the vector residual should be a zero vector.</p>\n\n<p>Orthogonal vectors: The scalar residual should be 0, and the vector residual should be a zero vector.</p>\n\n<p>You can run this test function to check if the calculate_residuals function works correctly. If all test cases pass, you will see the message \"All test cases passed!\" printed in the console.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function uses the assert keyword to check if the test cases pass. If the test cases fail, an AssertionError will be raised and the test function will terminate.</p>\n\n<pre><code>np.allclose is a NumPy function that checks if all elements in two arrays are element-wise equal within a given tolerance. It returns True if all elements in the arrays are close, and False otherwise. The default tolerance is 1e-8.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">0.4</span>, </span><span class=\"param\"><span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">relative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.test_calc_resid_ica", "modulename": "modules.validate_1d", "qualname": "test_calc_resid_ica", "kind": "function", "doc": "<p>Test the calc_resid function with different cases of input vectors a and b.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.calculate_residuals", "modulename": "modules.validate_1d", "qualname": "calculate_residuals", "kind": "function", "doc": "<p>Compute both scalar &amp; vector residuals between $x$ &amp; $y$, where $x$ is the source field and $y$ is the estimated field.</p>\n\n<p>The residual (b - <b\\cdot a><a\\cdot a>^-1 a) or its magnitude, an associated quadratic. Here a is the input nonG and b is the output nonG, and if it was perfect separation this would be zero.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.ndarray\n    True field $x$. Must be same shape as $y$.\ny : np.ndarray\n    Extracted field $y$. Must be same shape as $x$.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>rs : float\n    Scalar residual of $x$ and $y$ (see below).\nrv : np.ndarray\n    Vector residual of $x$ and $y$ (see below).</p>\n\n<h2 id=\"notes\">Notes</h2>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span>, </span><span class=\"param\"><span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">relative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.test_calculate_residuals", "modulename": "modules.validate_1d", "qualname": "test_calculate_residuals", "kind": "function", "doc": "<p>Test calculate_residuals() function.</p>\n\n<p>This test function checks three different cases:</p>\n\n<p>Identical vectors: The scalar residual should be 1, and the vector residual should be equal to the original vector a.</p>\n\n<p>Opposite vectors: The scalar residual should be -1, and the vector residual should be a zero vector.</p>\n\n<p>Orthogonal vectors: The scalar residual should be 0, and the vector residual should be a zero vector.</p>\n\n<p>You can run this test function to check if the calculate_residuals function works correctly. If all test cases pass, you will see the message \"All test cases passed!\" printed in the console.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>None</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>None</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>This function uses the assert keyword to check if the test cases pass. If the test cases fail, an AssertionError will be raised and the test function will terminate.</p>\n\n<pre><code>np.allclose is a NumPy function that checks if all elements in two arrays are element-wise equal within a given tolerance. It returns True if all elements in the arrays are close, and False otherwise. The default absolute tolerance (atol) is 1e-8, and the default relative tolerance (rtol) is 1e-5.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">0.4</span>, </span><span class=\"param\"><span class=\"n\">norm</span><span class=\"o\">=</span><span class=\"kc\">True</span>, </span><span class=\"param\"><span class=\"n\">relative</span><span class=\"o\">=</span><span class=\"kc\">True</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.calculate_pearson_coefficient", "modulename": "modules.validate_1d", "qualname": "calculate_pearson_coefficient", "kind": "function", "doc": "<p>Calculate Pearson correlation coefficient between two fields, where $x$ is the source field and $y$ is the estimated field.</p>\n\n<p>The Pearson correlation coefficient is a measure of the linear correlation between two variables $X$ and $Y$.\nIt has a value between -1 and 1, where 1 is total positive linear correlation, 0 is no linear correlation, and -1 is total negative linear correlation.\nThe mathematical definition of the coefficient is:\n    $r = \\frac{\\sum_{i=1}^{n} (x_i - \\bar{x})(y_i - \\bar{y})}{\\sqrt{\\sum_{i=1}^{n} (x_i - \\bar{x})^2 \\sum_{i=1}^{n} (y_i - \\bar{y})^2}}$\nwhere $\\bar{x}$ is the mean of the data in $X$ and $\\bar{y}$ is the mean of the data in $Y$.\nThe coefficient is also known as the Pearson product-moment correlation coefficient.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.ndarray\n    The true field.\ny : np.ndarray\n    The extracted field.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>correlation_coefficient : float</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<pre><code>&gt;&gt;&gt; true_field = np.random.randn(100)  # Replace with your true NG field\n&gt;&gt;&gt; extracted_field = np.random.randn(100)  # Replace with your extracted NG field\n&gt;&gt;&gt; correlation_coefficient = calculate_pearson_coefficient(true_field, extracted_field)\n&gt;&gt;&gt; print(\"Pearson Correlation Coefficient:\", correlation_coefficient)\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>Keep in mind that the Pearson Correlation Coefficient only measures the linear relationship between the two fields. If your problem requires assessing the performance of your component separation algorithm in recovering more complex relationships, you may need to consider alternative or additional metrics.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.biweight_midcorrelation", "modulename": "modules.validate_1d", "qualname": "biweight_midcorrelation", "kind": "function", "doc": "<p>Calculate the biweight midcorrelation between two fields, where $x$ is the source field and $y$ is the estimated field.</p>\n\n<p>Biweight midcorrelation is a robust correlation measur between two variables $X$ and $Y$ based on the biweight midvariance, which is a robust alternative to the classical variance. It calculates the correlation between two variables while down-weighting the contribution of outliers. The biweight midcorrelation ranges from -1 to 1, similar to the Pearson correlation coefficient, with 1 indicating a perfect positive relationship, -1 a perfect negative relationship, and 0 no relationship.\nThe mathematical definition of the biweight midcorrelation is:\n    $r_{bc} = \\frac{\\sum_{i=1}^{n} (x_i - \\tilde{x})(y_i - \\tilde{y})}{\\sqrt{\\sum_{i=1}^{n} (x_i - \\tilde{x})^2 \\sum_{i=1}^{n} (y_i - \\tilde{y})^2}}$</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>x : np.ndarray\n    The true field.\ny : np.ndarray\n    The extracted field.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>correlation_coefficient : float\n    The biweight midcorrelation between the two fields.</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<pre><code>&gt;&gt;&gt; x = np.array([1, 2, 3, 4, 5, 100])  # Original/reference field\n&gt;&gt;&gt; y = np.array([1.2, 2.1, 2.9, 4.1, 5.2, 101])  # Extracted/estimated field\n\n&gt;&gt;&gt; result = biweight_midcorrelation(x, y)\n&gt;&gt;&gt; print(f\"Biweight midcorrelation: {result:.2f}\")\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>Keep in mind that this method assumes that your data is reasonably well-behaved (i.e., the majority of the data points are not outliers), as extreme cases with a large number of outliers can still affect the biweight midcorrelation. If you think your data might have a high percentage of outliers or other peculiarities, consider exploring other robust correlation methods as well.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">x</span>, </span><span class=\"param\"><span class=\"n\">y</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.validate_1d.rescale_extracted_field", "modulename": "modules.validate_1d", "qualname": "rescale_extracted_field", "kind": "function", "doc": "<p>Rescale the extracted field to match the true field.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>true_field : np.ndarray\n    The true field.\nextracted_field : np.ndarray\n    The extracted field.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>extracted_field : np.ndarray\n    The extracted field rescaled to match the true field.</p>\n\n<h2 id=\"notes\">Notes</h2>\n\n<p>Rescale the extracted field to match the true field by:\n    1) Dividing the extracted field by its standard deviation.\n    3) Multiplying the extracted field by the standard deviation of the true field.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">true_field</span>, </span><span class=\"param\"><span class=\"n\">extracted_field</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.visualize", "modulename": "modules.visualize", "kind": "module", "doc": "<p>Visualization functions for ICA.</p>\n\n<p>This module contains helper functions for ICA that can be used to plot source components and ICA-separated\nsignals and plot the ICA filter used for $kf$-ICA separation.</p>\n\n<h2 id=\"routine-listings\">Routine Listings</h2>\n\n<p>plt_icaflt(src, ica_src, kc, max_amps, fontsize=8)\n    Plot source components and ICA-separated signals\nplt_filters(ica, kc, max_amps, fontsize=8)\n    Plot the ICA filter used for $kf$-ICA separation.</p>\n\n<h2 id=\"see-also\">See Also</h2>\n\n<p>ica.modules.ica</p>\n\n<h2 id=\"notes\">Notes</h2>\n"}, {"fullname": "modules.visualize.plt_icaflt", "modulename": "modules.visualize", "qualname": "plt_icaflt", "kind": "function", "doc": "<p>Plot source components and ICA-separated signals</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>src\n    Source components.\nica_src\n    ICA-separated signals\nkc\n    wavenumber bin limits\nmax_amps\n    Maximum amplitudes of source components and ICA-separated signals.\nfontsize, optional\n    Font size for plots.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>None\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>1) Unfiltered source components are plotted in the top row.\n2) Filtered source components are plotted in the subsequent rows.\n3) The first column plots the source components.\n4) The second column plots the ICA-separated signals.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">src</span>, </span><span class=\"param\"><span class=\"n\">ica_src</span>, </span><span class=\"param\"><span class=\"n\">kc</span>, </span><span class=\"param\"><span class=\"n\">max_amps</span>, </span><span class=\"param\"><span class=\"n\">fontsize</span><span class=\"o\">=</span><span class=\"mi\">8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.visualize.plt_filters", "modulename": "modules.visualize", "qualname": "plt_filters", "kind": "function", "doc": "<p>Plot the filters used in the filtering process.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p>N\n    field size\nkc\n    The wavenumber bins limits.\nfzkt\n    Filtered Fourier transform of the source components.\nzkt\n    Fourier transform of the source components.\nhannf\n    Hann window\nfontsize, optional\n    Font size.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<pre><code>None. Plots the filters used in the filtering process.\n</code></pre>\n\n<h2 id=\"notes\">Notes</h2>\n\n<pre><code>The filters are plotted in the frequency domain.\n</code></pre>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">N</span>, </span><span class=\"param\"><span class=\"n\">kc</span>, </span><span class=\"param\"><span class=\"n\">fzkt</span>, </span><span class=\"param\"><span class=\"n\">zkt</span>, </span><span class=\"param\"><span class=\"n\">hannf</span>, </span><span class=\"param\"><span class=\"n\">fontsize</span><span class=\"o\">=</span><span class=\"mi\">8</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "modules.zrandomcode", "modulename": "modules.zrandomcode", "kind": "module", "doc": "<p></p>\n"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();